# Обработка на изходен код

В рамките на този проект трябва да се разработи приложение, което получава като вход един
или повече файлове с изходен код на C/C++ и прилага върху тях серия от операции. Операциите,
които приложението трябва да изпълнява върху изходния код са описани по-долу.
При стартирането на приложението, потребителят избира кои операции да се извършват върху
файловете и в какъв ред. Ако той избере две или повече операции, прилагането им върху
файловете трябва да бъде последователно, т.е. докато не приключи прилагането на една операция
върху даден фрагмент изходен код, не може да се премине към следващата. Някои от операциите
могат да имат входни параметри, които определят начина им на работа.

# Операции

- Премахване на коментари от файл
Команда: --comments
Тази операция премахва всички коментари от даден фрагмент код. Операцията няма
параметри. Тя премахва коментари от вид /* */ и //. Резултатът от обработката е нов фрагмент, от
който са премахнати коментарите, а останалото съдържание е същото като в оригинала.

- Нормализиране на нови редове
Команда: --newlines=<format>
Новите редове в един фрагмент могат да бъдат в различен формат (например някои редове
могат да завършват с \n, а други с \r\n). Операцията трябва да коригира редовете във фрагмента,
като ги конвертира до посочен от потребителя формат.
Операцията има един аргумент, който може да има една от следните стойности:
 CRLF – всички нови редове стават \r\n (т.е. \n се подменя с \r\n)
 LF – всички нови редове стават \n

- Нормализиране на отстъпа
Команда: --indentation=<format>
В даден фрагмент код отстъпите могат да бъдат въведени със символ за табулация (\t) или с
четири символа за интервал. Възможно е във фрагмента тези два стила да са смесени (т.е. в един
ред да има табулации, в друг – интервали, в трети – и табулации, и интервали и т.н.). Операцията за
нормализиране на отстъпите получава един аргумент, който указва кой от двата стила предпочита
потребителят – табулации (tabs) или интервали (spaces). Резултатът е нов фрагмент, в който всички
отстъпи са форматирани в желания формат. Например ако потребителят предпочита табулации,
операцията трябва да подмени всички срещания на четири интервала със символ за табулация. 

- Подреждане на код
Команда: --format
Тази операция няма аргументи. Тя получава фрагмент код и трябва да оправи форматирането в
него там, където е нужно. Това трябва да стане по следния начин:
1. Всяка инструкция (statement) трябва да започва на отделен ред.
ПРЕДИ:
int x, y; if( 1 > 2) return;
СЛЕД:
int x, y;
if( 1 > 2) return;
2. Вложените блокове и телата на if, for, while и т.н. трябва да бъдат на нов ред и с един
отстъп навътре. Например:
ПРЕДИ:
if(1 > 2) return; else
 {
 int x, y;
int z;
 }
СЛЕД:
if(1 > 2)
 return;
else
{
 int x, y;
 int z;
}

- Оцветяване на код
Команда: --html
Операцията получава фрагмент код и го форматира като HTML. Операцията няма аргументи.
Резултатът трябва да бъде валиден HTML код, в който са маркирани:
 Коментарите
 Запазените думи в езика
 Символните низове (стрингове)
 Препроцесорните директиви
 Числовите литерали (напр. 1, 5.5, .9, 1e3)
 Символните литерали (напр. ‘c’, ‘\t’)
Самите изберете какво да бъде маркирането. Например запазените думи може да са сини и с
получер шрифт (bold), коментарите да са в зелен курсив, числовите литерали да са оранжеви и т.н.
ВАЖНО: Това е единствената команда, за която не важи правилото за последователно
прилагане. Независимо къде е указана тази команда, тя трябва да се изпълни само веднъж и то
накрая, след като са изпълнени останалите операции върху дадения файл.

# Вход
Приложението ви трябва да получава входа си от командния ред. Потребителят може да
подава два вида аргументи – операции и пътища (пълни или относителни) към файловете, които
трябва да се обработят. За да може двата вида аргументи да се различават, всички операции
започват с два символа за тире (--).

Някои от операциите могат да имат аргументи, които определят начина им на работа. Ако
операцията има аргументи, те се подават като след името ѝ се сложи символ за равенство и след
него се подаде стойността на аргумента. Ето как може да изглежда един примерен вход:
prog.exe --comments --newlines=CRLF --tabs=tabs file.cpp C:\temp\1.cpp

Тук приложението ви получава три операции (--comments, --newlines и --tabs). Две от тях имат
аргумент. Това са --newlines, която има за аргумент символния низ CRLF и --tabs, която има за
аргумент символния низ tabs. file.cpp е относителното име на файл, който програмата трябва да
обработи, а C:\temp\1.cpp – пълно име на друг файл.
Потребителят може да указва операциите и имената на файловете в какъвто пожелае ред.
Например дадената по-долу команда трябва да се обработи идентично на предишната:
prog.exe file.cpp --comments --newlines=CRLF C:\temp\1.cpp --tabs=tabs

При това има две правила, които трябва да се спазват:
1. Файловете се обработват точно в реда, в който са подадени от командния ред. Тоест в
случая file.cpp ще се обработи преди 1.cpp.
2. Освен ако не е казано друго, за всеки отделен файл, операциите също се изпълняват точно
в реда, в който са дадени.
Това означава, че в нашия пример последователността на операциите ще изглежда така:
1. Изпълнява се --comments върху file.cpp;
2. Изпълнява се --newlines върху file.cpp;
3. Изпълнява се --tabs върху file.cpp;
4. Изпълнява се --comments върху 1.cpp;
5. Изпълнява се --newlines върху 1.cpp;
6. Прилага се --tabs върху 1.cpp;

# Изход

Ако потребителят избере опция да генерира HTML файл, за всеки входен файл, програмата
трябва да генерира нов файл със същото име и разширение .html. Например
prog.exe --html --indentation=tabs file.cpp C:\temp\1.cpp
трябва да генерира два нови файла: file.html и C:\temp\1.html

Ако потребителят не е избрал опция за генериране на HTML файл, старото съдържание на
файловете трябва да се запише във файлове с разширение .old, а съществуващите файлове да се
променят. 
Например prog.exe --tabs=tabs file.cpp C:\temp\1.cpp
трябва да генерира два файла file.cpp.old и C:\temp\1.cpp.old, в които ще запази старото
съдържание, а във файловете file.cpp и 1.cpp ще се запише резултатът от обработката.
